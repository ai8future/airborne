// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: markdownsvc/v1/markdown.proto

package markdownsvcv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// OutputFormat specifies how HTML should be rendered.
type OutputFormat int32

const (
	// Standard HTML with CSS classes (default behavior).
	OutputFormat_OUTPUT_FORMAT_HTML OutputFormat = 0
	// Email-safe HTML with inline styles and SVG math.
	OutputFormat_OUTPUT_FORMAT_EMAIL_HTML OutputFormat = 1
)

// Enum value maps for OutputFormat.
var (
	OutputFormat_name = map[int32]string{
		0: "OUTPUT_FORMAT_HTML",
		1: "OUTPUT_FORMAT_EMAIL_HTML",
	}
	OutputFormat_value = map[string]int32{
		"OUTPUT_FORMAT_HTML":       0,
		"OUTPUT_FORMAT_EMAIL_HTML": 1,
	}
)

func (x OutputFormat) Enum() *OutputFormat {
	p := new(OutputFormat)
	*p = x
	return p
}

func (x OutputFormat) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (OutputFormat) Descriptor() protoreflect.EnumDescriptor {
	return file_markdownsvc_v1_markdown_proto_enumTypes[0].Descriptor()
}

func (OutputFormat) Type() protoreflect.EnumType {
	return &file_markdownsvc_v1_markdown_proto_enumTypes[0]
}

func (x OutputFormat) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use OutputFormat.Descriptor instead.
func (OutputFormat) EnumDescriptor() ([]byte, []int) {
	return file_markdownsvc_v1_markdown_proto_rawDescGZIP(), []int{0}
}

// ParseMarkdownRequest is the primary request message for markdown processing.
type ParseMarkdownRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The markdown content to process.
	Content string `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	// Plugin configuration - choose one approach:
	// Named preset from presets.yaml (e.g., "github", "technical-docs", "blog")
	Preset string `protobuf:"bytes,2,opt,name=preset,proto3" json:"preset,omitempty"`
	// OR explicit plugin list (overrides preset if both provided)
	Plugins []*PluginConfig `protobuf:"bytes,3,rep,name=plugins,proto3" json:"plugins,omitempty"`
	// Optional: also render to HTML
	IncludeHtml bool `protobuf:"varint,4,opt,name=include_html,json=includeHtml,proto3" json:"include_html,omitempty"`
	// Sanitization preset for HTML output: "github", "strict", "none"
	SanitizationPreset string `protobuf:"bytes,5,opt,name=sanitization_preset,json=sanitizationPreset,proto3" json:"sanitization_preset,omitempty"`
	// Optional: custom rehype-sanitize schema as JSON
	CustomSchemaJson string `protobuf:"bytes,6,opt,name=custom_schema_json,json=customSchemaJson,proto3" json:"custom_schema_json,omitempty"`
	// Optional: apply transforms in same call
	Transforms []*Transform `protobuf:"bytes,7,rep,name=transforms,proto3" json:"transforms,omitempty"`
	// Output format for HTML rendering.
	OutputFormat  OutputFormat `protobuf:"varint,8,opt,name=output_format,json=outputFormat,proto3,enum=markdownsvc.v1.OutputFormat" json:"output_format,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ParseMarkdownRequest) Reset() {
	*x = ParseMarkdownRequest{}
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ParseMarkdownRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ParseMarkdownRequest) ProtoMessage() {}

func (x *ParseMarkdownRequest) ProtoReflect() protoreflect.Message {
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ParseMarkdownRequest.ProtoReflect.Descriptor instead.
func (*ParseMarkdownRequest) Descriptor() ([]byte, []int) {
	return file_markdownsvc_v1_markdown_proto_rawDescGZIP(), []int{0}
}

func (x *ParseMarkdownRequest) GetContent() string {
	if x != nil {
		return x.Content
	}
	return ""
}

func (x *ParseMarkdownRequest) GetPreset() string {
	if x != nil {
		return x.Preset
	}
	return ""
}

func (x *ParseMarkdownRequest) GetPlugins() []*PluginConfig {
	if x != nil {
		return x.Plugins
	}
	return nil
}

func (x *ParseMarkdownRequest) GetIncludeHtml() bool {
	if x != nil {
		return x.IncludeHtml
	}
	return false
}

func (x *ParseMarkdownRequest) GetSanitizationPreset() string {
	if x != nil {
		return x.SanitizationPreset
	}
	return ""
}

func (x *ParseMarkdownRequest) GetCustomSchemaJson() string {
	if x != nil {
		return x.CustomSchemaJson
	}
	return ""
}

func (x *ParseMarkdownRequest) GetTransforms() []*Transform {
	if x != nil {
		return x.Transforms
	}
	return nil
}

func (x *ParseMarkdownRequest) GetOutputFormat() OutputFormat {
	if x != nil {
		return x.OutputFormat
	}
	return OutputFormat_OUTPUT_FORMAT_HTML
}

// PluginConfig specifies a remark plugin and its options.
type PluginConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Plugin name (e.g., "remark-gfm", "remark-math", "remark-emoji")
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// JSON options for the plugin (optional)
	Options       string `protobuf:"bytes,2,opt,name=options,proto3" json:"options,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PluginConfig) Reset() {
	*x = PluginConfig{}
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PluginConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PluginConfig) ProtoMessage() {}

func (x *PluginConfig) ProtoReflect() protoreflect.Message {
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PluginConfig.ProtoReflect.Descriptor instead.
func (*PluginConfig) Descriptor() ([]byte, []int) {
	return file_markdownsvc_v1_markdown_proto_rawDescGZIP(), []int{1}
}

func (x *PluginConfig) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *PluginConfig) GetOptions() string {
	if x != nil {
		return x.Options
	}
	return ""
}

// ParseMarkdownResponse contains the results of markdown processing.
type ParseMarkdownResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The parsed AST as JSON (mdast format). Always returned.
	AstJson string `protobuf:"bytes,1,opt,name=ast_json,json=astJson,proto3" json:"ast_json,omitempty"`
	// Rendered HTML. Only populated if include_html=true.
	Html string `protobuf:"bytes,2,opt,name=html,proto3" json:"html,omitempty"`
	// Transform results. Only populated if transforms were requested.
	Results       []*TransformResult `protobuf:"bytes,3,rep,name=results,proto3" json:"results,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ParseMarkdownResponse) Reset() {
	*x = ParseMarkdownResponse{}
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ParseMarkdownResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ParseMarkdownResponse) ProtoMessage() {}

func (x *ParseMarkdownResponse) ProtoReflect() protoreflect.Message {
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ParseMarkdownResponse.ProtoReflect.Descriptor instead.
func (*ParseMarkdownResponse) Descriptor() ([]byte, []int) {
	return file_markdownsvc_v1_markdown_proto_rawDescGZIP(), []int{2}
}

func (x *ParseMarkdownResponse) GetAstJson() string {
	if x != nil {
		return x.AstJson
	}
	return ""
}

func (x *ParseMarkdownResponse) GetHtml() string {
	if x != nil {
		return x.Html
	}
	return ""
}

func (x *ParseMarkdownResponse) GetResults() []*TransformResult {
	if x != nil {
		return x.Results
	}
	return nil
}

// RenderToHTMLRequest is a convenience request for HTML-only output.
type RenderToHTMLRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The markdown content to render.
	Content string `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	// Plugin configuration
	Preset  string          `protobuf:"bytes,2,opt,name=preset,proto3" json:"preset,omitempty"`
	Plugins []*PluginConfig `protobuf:"bytes,3,rep,name=plugins,proto3" json:"plugins,omitempty"`
	// Sanitization preset: "github", "strict", "none"
	SanitizationPreset string `protobuf:"bytes,4,opt,name=sanitization_preset,json=sanitizationPreset,proto3" json:"sanitization_preset,omitempty"`
	// Optional: custom rehype-sanitize schema as JSON
	CustomSchemaJson string `protobuf:"bytes,5,opt,name=custom_schema_json,json=customSchemaJson,proto3" json:"custom_schema_json,omitempty"`
	// Output format for HTML rendering.
	OutputFormat  OutputFormat `protobuf:"varint,6,opt,name=output_format,json=outputFormat,proto3,enum=markdownsvc.v1.OutputFormat" json:"output_format,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RenderToHTMLRequest) Reset() {
	*x = RenderToHTMLRequest{}
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RenderToHTMLRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RenderToHTMLRequest) ProtoMessage() {}

func (x *RenderToHTMLRequest) ProtoReflect() protoreflect.Message {
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RenderToHTMLRequest.ProtoReflect.Descriptor instead.
func (*RenderToHTMLRequest) Descriptor() ([]byte, []int) {
	return file_markdownsvc_v1_markdown_proto_rawDescGZIP(), []int{3}
}

func (x *RenderToHTMLRequest) GetContent() string {
	if x != nil {
		return x.Content
	}
	return ""
}

func (x *RenderToHTMLRequest) GetPreset() string {
	if x != nil {
		return x.Preset
	}
	return ""
}

func (x *RenderToHTMLRequest) GetPlugins() []*PluginConfig {
	if x != nil {
		return x.Plugins
	}
	return nil
}

func (x *RenderToHTMLRequest) GetSanitizationPreset() string {
	if x != nil {
		return x.SanitizationPreset
	}
	return ""
}

func (x *RenderToHTMLRequest) GetCustomSchemaJson() string {
	if x != nil {
		return x.CustomSchemaJson
	}
	return ""
}

func (x *RenderToHTMLRequest) GetOutputFormat() OutputFormat {
	if x != nil {
		return x.OutputFormat
	}
	return OutputFormat_OUTPUT_FORMAT_HTML
}

// RenderToHTMLResponse contains the rendered HTML.
type RenderToHTMLResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The sanitized HTML output.
	Html          string `protobuf:"bytes,1,opt,name=html,proto3" json:"html,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RenderToHTMLResponse) Reset() {
	*x = RenderToHTMLResponse{}
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RenderToHTMLResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RenderToHTMLResponse) ProtoMessage() {}

func (x *RenderToHTMLResponse) ProtoReflect() protoreflect.Message {
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RenderToHTMLResponse.ProtoReflect.Descriptor instead.
func (*RenderToHTMLResponse) Descriptor() ([]byte, []int) {
	return file_markdownsvc_v1_markdown_proto_rawDescGZIP(), []int{4}
}

func (x *RenderToHTMLResponse) GetHtml() string {
	if x != nil {
		return x.Html
	}
	return ""
}

// ChunkMarkdownRequest is used for semantic chunking.
type ChunkMarkdownRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The markdown content to chunk.
	Content string `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	// Chunking options.
	Options       *ChunkingOptions `protobuf:"bytes,2,opt,name=options,proto3" json:"options,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChunkMarkdownRequest) Reset() {
	*x = ChunkMarkdownRequest{}
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChunkMarkdownRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChunkMarkdownRequest) ProtoMessage() {}

func (x *ChunkMarkdownRequest) ProtoReflect() protoreflect.Message {
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChunkMarkdownRequest.ProtoReflect.Descriptor instead.
func (*ChunkMarkdownRequest) Descriptor() ([]byte, []int) {
	return file_markdownsvc_v1_markdown_proto_rawDescGZIP(), []int{5}
}

func (x *ChunkMarkdownRequest) GetContent() string {
	if x != nil {
		return x.Content
	}
	return ""
}

func (x *ChunkMarkdownRequest) GetOptions() *ChunkingOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

// ChunkingOptions configures the chunking behavior.
type ChunkingOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Maximum characters per chunk (default 1000).
	MaxChunkSize int32 `protobuf:"varint,1,opt,name=max_chunk_size,json=maxChunkSize,proto3" json:"max_chunk_size,omitempty"`
	// Overlap between chunks in characters (default 100).
	OverlapSize int32 `protobuf:"varint,2,opt,name=overlap_size,json=overlapSize,proto3" json:"overlap_size,omitempty"`
	// Keep code blocks intact even if they exceed max_chunk_size.
	PreserveCodeBlocks bool `protobuf:"varint,3,opt,name=preserve_code_blocks,json=preserveCodeBlocks,proto3" json:"preserve_code_blocks,omitempty"`
	// Include metadata (section path, headings) in each chunk.
	IncludeMetadata bool `protobuf:"varint,4,opt,name=include_metadata,json=includeMetadata,proto3" json:"include_metadata,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ChunkingOptions) Reset() {
	*x = ChunkingOptions{}
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChunkingOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChunkingOptions) ProtoMessage() {}

func (x *ChunkingOptions) ProtoReflect() protoreflect.Message {
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChunkingOptions.ProtoReflect.Descriptor instead.
func (*ChunkingOptions) Descriptor() ([]byte, []int) {
	return file_markdownsvc_v1_markdown_proto_rawDescGZIP(), []int{6}
}

func (x *ChunkingOptions) GetMaxChunkSize() int32 {
	if x != nil {
		return x.MaxChunkSize
	}
	return 0
}

func (x *ChunkingOptions) GetOverlapSize() int32 {
	if x != nil {
		return x.OverlapSize
	}
	return 0
}

func (x *ChunkingOptions) GetPreserveCodeBlocks() bool {
	if x != nil {
		return x.PreserveCodeBlocks
	}
	return false
}

func (x *ChunkingOptions) GetIncludeMetadata() bool {
	if x != nil {
		return x.IncludeMetadata
	}
	return false
}

// ChunkMarkdownResponse contains the chunked output.
type ChunkMarkdownResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The semantic chunks.
	Chunks []*MarkdownChunk `protobuf:"bytes,1,rep,name=chunks,proto3" json:"chunks,omitempty"`
	// Document outline (heading structure).
	Outline       *DocumentOutline `protobuf:"bytes,2,opt,name=outline,proto3" json:"outline,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChunkMarkdownResponse) Reset() {
	*x = ChunkMarkdownResponse{}
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChunkMarkdownResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChunkMarkdownResponse) ProtoMessage() {}

func (x *ChunkMarkdownResponse) ProtoReflect() protoreflect.Message {
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChunkMarkdownResponse.ProtoReflect.Descriptor instead.
func (*ChunkMarkdownResponse) Descriptor() ([]byte, []int) {
	return file_markdownsvc_v1_markdown_proto_rawDescGZIP(), []int{7}
}

func (x *ChunkMarkdownResponse) GetChunks() []*MarkdownChunk {
	if x != nil {
		return x.Chunks
	}
	return nil
}

func (x *ChunkMarkdownResponse) GetOutline() *DocumentOutline {
	if x != nil {
		return x.Outline
	}
	return nil
}

// MarkdownChunk represents a semantic chunk of the document.
type MarkdownChunk struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The chunk content (markdown text).
	Content string `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	// Metadata about this chunk.
	Metadata      *ChunkMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MarkdownChunk) Reset() {
	*x = MarkdownChunk{}
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MarkdownChunk) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MarkdownChunk) ProtoMessage() {}

func (x *MarkdownChunk) ProtoReflect() protoreflect.Message {
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MarkdownChunk.ProtoReflect.Descriptor instead.
func (*MarkdownChunk) Descriptor() ([]byte, []int) {
	return file_markdownsvc_v1_markdown_proto_rawDescGZIP(), []int{8}
}

func (x *MarkdownChunk) GetContent() string {
	if x != nil {
		return x.Content
	}
	return ""
}

func (x *MarkdownChunk) GetMetadata() *ChunkMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// ChunkMetadata contains information about a chunk's position and context.
type ChunkMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Zero-based index of this chunk.
	Index int32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	// Character offset where this chunk starts in the original document.
	StartOffset int32 `protobuf:"varint,2,opt,name=start_offset,json=startOffset,proto3" json:"start_offset,omitempty"`
	// Character offset where this chunk ends.
	EndOffset int32 `protobuf:"varint,3,opt,name=end_offset,json=endOffset,proto3" json:"end_offset,omitempty"`
	// Hierarchical section path (e.g., ["Chapter 1", "Introduction"]).
	SectionPath []string `protobuf:"bytes,4,rep,name=section_path,json=sectionPath,proto3" json:"section_path,omitempty"`
	// The nearest heading above this chunk.
	HeadingContext string `protobuf:"bytes,5,opt,name=heading_context,json=headingContext,proto3" json:"heading_context,omitempty"`
	// The type of content in this chunk (e.g., "paragraph", "code", "list").
	ChunkType     string `protobuf:"bytes,6,opt,name=chunk_type,json=chunkType,proto3" json:"chunk_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChunkMetadata) Reset() {
	*x = ChunkMetadata{}
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChunkMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChunkMetadata) ProtoMessage() {}

func (x *ChunkMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChunkMetadata.ProtoReflect.Descriptor instead.
func (*ChunkMetadata) Descriptor() ([]byte, []int) {
	return file_markdownsvc_v1_markdown_proto_rawDescGZIP(), []int{9}
}

func (x *ChunkMetadata) GetIndex() int32 {
	if x != nil {
		return x.Index
	}
	return 0
}

func (x *ChunkMetadata) GetStartOffset() int32 {
	if x != nil {
		return x.StartOffset
	}
	return 0
}

func (x *ChunkMetadata) GetEndOffset() int32 {
	if x != nil {
		return x.EndOffset
	}
	return 0
}

func (x *ChunkMetadata) GetSectionPath() []string {
	if x != nil {
		return x.SectionPath
	}
	return nil
}

func (x *ChunkMetadata) GetHeadingContext() string {
	if x != nil {
		return x.HeadingContext
	}
	return ""
}

func (x *ChunkMetadata) GetChunkType() string {
	if x != nil {
		return x.ChunkType
	}
	return ""
}

// DocumentOutline represents the heading structure of the document.
type DocumentOutline struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Top-level outline nodes.
	Nodes         []*OutlineNode `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DocumentOutline) Reset() {
	*x = DocumentOutline{}
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DocumentOutline) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DocumentOutline) ProtoMessage() {}

func (x *DocumentOutline) ProtoReflect() protoreflect.Message {
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DocumentOutline.ProtoReflect.Descriptor instead.
func (*DocumentOutline) Descriptor() ([]byte, []int) {
	return file_markdownsvc_v1_markdown_proto_rawDescGZIP(), []int{10}
}

func (x *DocumentOutline) GetNodes() []*OutlineNode {
	if x != nil {
		return x.Nodes
	}
	return nil
}

// OutlineNode represents a heading in the document outline.
type OutlineNode struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Heading depth (1-6).
	Depth int32 `protobuf:"varint,1,opt,name=depth,proto3" json:"depth,omitempty"`
	// Heading text.
	Text string `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
	// Character offset of the heading in the original document.
	StartOffset int32 `protobuf:"varint,3,opt,name=start_offset,json=startOffset,proto3" json:"start_offset,omitempty"`
	// Child headings.
	Children      []*OutlineNode `protobuf:"bytes,4,rep,name=children,proto3" json:"children,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OutlineNode) Reset() {
	*x = OutlineNode{}
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OutlineNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OutlineNode) ProtoMessage() {}

func (x *OutlineNode) ProtoReflect() protoreflect.Message {
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OutlineNode.ProtoReflect.Descriptor instead.
func (*OutlineNode) Descriptor() ([]byte, []int) {
	return file_markdownsvc_v1_markdown_proto_rawDescGZIP(), []int{11}
}

func (x *OutlineNode) GetDepth() int32 {
	if x != nil {
		return x.Depth
	}
	return 0
}

func (x *OutlineNode) GetText() string {
	if x != nil {
		return x.Text
	}
	return ""
}

func (x *OutlineNode) GetStartOffset() int32 {
	if x != nil {
		return x.StartOffset
	}
	return 0
}

func (x *OutlineNode) GetChildren() []*OutlineNode {
	if x != nil {
		return x.Children
	}
	return nil
}

// TransformASTRequest applies transforms to markdown or an existing AST.
type TransformASTRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Raw markdown content (preferred for one-call convenience).
	Content string `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	// OR pre-parsed AST JSON (for chaining operations).
	// One of content or ast_json must be provided.
	AstJson string `protobuf:"bytes,2,opt,name=ast_json,json=astJson,proto3" json:"ast_json,omitempty"`
	// Transforms to apply.
	Transforms    []*Transform `protobuf:"bytes,3,rep,name=transforms,proto3" json:"transforms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TransformASTRequest) Reset() {
	*x = TransformASTRequest{}
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransformASTRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransformASTRequest) ProtoMessage() {}

func (x *TransformASTRequest) ProtoReflect() protoreflect.Message {
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransformASTRequest.ProtoReflect.Descriptor instead.
func (*TransformASTRequest) Descriptor() ([]byte, []int) {
	return file_markdownsvc_v1_markdown_proto_rawDescGZIP(), []int{12}
}

func (x *TransformASTRequest) GetContent() string {
	if x != nil {
		return x.Content
	}
	return ""
}

func (x *TransformASTRequest) GetAstJson() string {
	if x != nil {
		return x.AstJson
	}
	return ""
}

func (x *TransformASTRequest) GetTransforms() []*Transform {
	if x != nil {
		return x.Transforms
	}
	return nil
}

// Transform specifies a transformation to apply.
type Transform struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Built-in transform types: "remove_images", "extract_links", "strip_formatting"
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// JSON options for the transform (reserved for future use).
	Options       string `protobuf:"bytes,2,opt,name=options,proto3" json:"options,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Transform) Reset() {
	*x = Transform{}
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Transform) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Transform) ProtoMessage() {}

func (x *Transform) ProtoReflect() protoreflect.Message {
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Transform.ProtoReflect.Descriptor instead.
func (*Transform) Descriptor() ([]byte, []int) {
	return file_markdownsvc_v1_markdown_proto_rawDescGZIP(), []int{13}
}

func (x *Transform) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *Transform) GetOptions() string {
	if x != nil {
		return x.Options
	}
	return ""
}

// TransformASTResponse contains the results of AST transformation.
type TransformASTResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The transformed AST as JSON.
	AstJson string `protobuf:"bytes,1,opt,name=ast_json,json=astJson,proto3" json:"ast_json,omitempty"`
	// The AST re-serialized to markdown.
	Markdown string `protobuf:"bytes,2,opt,name=markdown,proto3" json:"markdown,omitempty"`
	// Results from each transform.
	Results       []*TransformResult `protobuf:"bytes,3,rep,name=results,proto3" json:"results,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TransformASTResponse) Reset() {
	*x = TransformASTResponse{}
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransformASTResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransformASTResponse) ProtoMessage() {}

func (x *TransformASTResponse) ProtoReflect() protoreflect.Message {
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransformASTResponse.ProtoReflect.Descriptor instead.
func (*TransformASTResponse) Descriptor() ([]byte, []int) {
	return file_markdownsvc_v1_markdown_proto_rawDescGZIP(), []int{14}
}

func (x *TransformASTResponse) GetAstJson() string {
	if x != nil {
		return x.AstJson
	}
	return ""
}

func (x *TransformASTResponse) GetMarkdown() string {
	if x != nil {
		return x.Markdown
	}
	return ""
}

func (x *TransformASTResponse) GetResults() []*TransformResult {
	if x != nil {
		return x.Results
	}
	return nil
}

// TransformResult contains the output of a specific transform.
type TransformResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The transform type that produced this result.
	TransformType string `protobuf:"bytes,1,opt,name=transform_type,json=transformType,proto3" json:"transform_type,omitempty"`
	// Links extracted by "extract_links" transform.
	Links []*ExtractedLink `protobuf:"bytes,2,rep,name=links,proto3" json:"links,omitempty"`
	// Plain text produced by "strip_formatting" transform.
	PlainText     string `protobuf:"bytes,3,opt,name=plain_text,json=plainText,proto3" json:"plain_text,omitempty"` // Add fields for future transforms without breaking proto compatibility.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TransformResult) Reset() {
	*x = TransformResult{}
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransformResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransformResult) ProtoMessage() {}

func (x *TransformResult) ProtoReflect() protoreflect.Message {
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransformResult.ProtoReflect.Descriptor instead.
func (*TransformResult) Descriptor() ([]byte, []int) {
	return file_markdownsvc_v1_markdown_proto_rawDescGZIP(), []int{15}
}

func (x *TransformResult) GetTransformType() string {
	if x != nil {
		return x.TransformType
	}
	return ""
}

func (x *TransformResult) GetLinks() []*ExtractedLink {
	if x != nil {
		return x.Links
	}
	return nil
}

func (x *TransformResult) GetPlainText() string {
	if x != nil {
		return x.PlainText
	}
	return ""
}

// ExtractedLink represents a link found in the document.
type ExtractedLink struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The link URL.
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// The link text.
	Text string `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
	// The link title attribute (if any).
	Title string `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	// Line number where the link appears.
	Line          int32 `protobuf:"varint,4,opt,name=line,proto3" json:"line,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExtractedLink) Reset() {
	*x = ExtractedLink{}
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExtractedLink) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExtractedLink) ProtoMessage() {}

func (x *ExtractedLink) ProtoReflect() protoreflect.Message {
	mi := &file_markdownsvc_v1_markdown_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExtractedLink.ProtoReflect.Descriptor instead.
func (*ExtractedLink) Descriptor() ([]byte, []int) {
	return file_markdownsvc_v1_markdown_proto_rawDescGZIP(), []int{16}
}

func (x *ExtractedLink) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *ExtractedLink) GetText() string {
	if x != nil {
		return x.Text
	}
	return ""
}

func (x *ExtractedLink) GetTitle() string {
	if x != nil {
		return x.Title
	}
	return ""
}

func (x *ExtractedLink) GetLine() int32 {
	if x != nil {
		return x.Line
	}
	return 0
}

var File_markdownsvc_v1_markdown_proto protoreflect.FileDescriptor

const file_markdownsvc_v1_markdown_proto_rawDesc = "" +
	"\n" +
	"\x1dmarkdownsvc/v1/markdown.proto\x12\x0emarkdownsvc.v1\"\x80\x03\n" +
	"\x14ParseMarkdownRequest\x12\x18\n" +
	"\acontent\x18\x01 \x01(\tR\acontent\x12\x16\n" +
	"\x06preset\x18\x02 \x01(\tR\x06preset\x126\n" +
	"\aplugins\x18\x03 \x03(\v2\x1c.markdownsvc.v1.PluginConfigR\aplugins\x12!\n" +
	"\finclude_html\x18\x04 \x01(\bR\vincludeHtml\x12/\n" +
	"\x13sanitization_preset\x18\x05 \x01(\tR\x12sanitizationPreset\x12,\n" +
	"\x12custom_schema_json\x18\x06 \x01(\tR\x10customSchemaJson\x129\n" +
	"\n" +
	"transforms\x18\a \x03(\v2\x19.markdownsvc.v1.TransformR\n" +
	"transforms\x12A\n" +
	"\routput_format\x18\b \x01(\x0e2\x1c.markdownsvc.v1.OutputFormatR\foutputFormat\"<\n" +
	"\fPluginConfig\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x18\n" +
	"\aoptions\x18\x02 \x01(\tR\aoptions\"\x81\x01\n" +
	"\x15ParseMarkdownResponse\x12\x19\n" +
	"\bast_json\x18\x01 \x01(\tR\aastJson\x12\x12\n" +
	"\x04html\x18\x02 \x01(\tR\x04html\x129\n" +
	"\aresults\x18\x03 \x03(\v2\x1f.markdownsvc.v1.TransformResultR\aresults\"\xa1\x02\n" +
	"\x13RenderToHTMLRequest\x12\x18\n" +
	"\acontent\x18\x01 \x01(\tR\acontent\x12\x16\n" +
	"\x06preset\x18\x02 \x01(\tR\x06preset\x126\n" +
	"\aplugins\x18\x03 \x03(\v2\x1c.markdownsvc.v1.PluginConfigR\aplugins\x12/\n" +
	"\x13sanitization_preset\x18\x04 \x01(\tR\x12sanitizationPreset\x12,\n" +
	"\x12custom_schema_json\x18\x05 \x01(\tR\x10customSchemaJson\x12A\n" +
	"\routput_format\x18\x06 \x01(\x0e2\x1c.markdownsvc.v1.OutputFormatR\foutputFormat\"*\n" +
	"\x14RenderToHTMLResponse\x12\x12\n" +
	"\x04html\x18\x01 \x01(\tR\x04html\"k\n" +
	"\x14ChunkMarkdownRequest\x12\x18\n" +
	"\acontent\x18\x01 \x01(\tR\acontent\x129\n" +
	"\aoptions\x18\x02 \x01(\v2\x1f.markdownsvc.v1.ChunkingOptionsR\aoptions\"\xb7\x01\n" +
	"\x0fChunkingOptions\x12$\n" +
	"\x0emax_chunk_size\x18\x01 \x01(\x05R\fmaxChunkSize\x12!\n" +
	"\foverlap_size\x18\x02 \x01(\x05R\voverlapSize\x120\n" +
	"\x14preserve_code_blocks\x18\x03 \x01(\bR\x12preserveCodeBlocks\x12)\n" +
	"\x10include_metadata\x18\x04 \x01(\bR\x0fincludeMetadata\"\x89\x01\n" +
	"\x15ChunkMarkdownResponse\x125\n" +
	"\x06chunks\x18\x01 \x03(\v2\x1d.markdownsvc.v1.MarkdownChunkR\x06chunks\x129\n" +
	"\aoutline\x18\x02 \x01(\v2\x1f.markdownsvc.v1.DocumentOutlineR\aoutline\"d\n" +
	"\rMarkdownChunk\x12\x18\n" +
	"\acontent\x18\x01 \x01(\tR\acontent\x129\n" +
	"\bmetadata\x18\x02 \x01(\v2\x1d.markdownsvc.v1.ChunkMetadataR\bmetadata\"\xd2\x01\n" +
	"\rChunkMetadata\x12\x14\n" +
	"\x05index\x18\x01 \x01(\x05R\x05index\x12!\n" +
	"\fstart_offset\x18\x02 \x01(\x05R\vstartOffset\x12\x1d\n" +
	"\n" +
	"end_offset\x18\x03 \x01(\x05R\tendOffset\x12!\n" +
	"\fsection_path\x18\x04 \x03(\tR\vsectionPath\x12'\n" +
	"\x0fheading_context\x18\x05 \x01(\tR\x0eheadingContext\x12\x1d\n" +
	"\n" +
	"chunk_type\x18\x06 \x01(\tR\tchunkType\"D\n" +
	"\x0fDocumentOutline\x121\n" +
	"\x05nodes\x18\x01 \x03(\v2\x1b.markdownsvc.v1.OutlineNodeR\x05nodes\"\x93\x01\n" +
	"\vOutlineNode\x12\x14\n" +
	"\x05depth\x18\x01 \x01(\x05R\x05depth\x12\x12\n" +
	"\x04text\x18\x02 \x01(\tR\x04text\x12!\n" +
	"\fstart_offset\x18\x03 \x01(\x05R\vstartOffset\x127\n" +
	"\bchildren\x18\x04 \x03(\v2\x1b.markdownsvc.v1.OutlineNodeR\bchildren\"\x85\x01\n" +
	"\x13TransformASTRequest\x12\x18\n" +
	"\acontent\x18\x01 \x01(\tR\acontent\x12\x19\n" +
	"\bast_json\x18\x02 \x01(\tR\aastJson\x129\n" +
	"\n" +
	"transforms\x18\x03 \x03(\v2\x19.markdownsvc.v1.TransformR\n" +
	"transforms\"9\n" +
	"\tTransform\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x12\x18\n" +
	"\aoptions\x18\x02 \x01(\tR\aoptions\"\x88\x01\n" +
	"\x14TransformASTResponse\x12\x19\n" +
	"\bast_json\x18\x01 \x01(\tR\aastJson\x12\x1a\n" +
	"\bmarkdown\x18\x02 \x01(\tR\bmarkdown\x129\n" +
	"\aresults\x18\x03 \x03(\v2\x1f.markdownsvc.v1.TransformResultR\aresults\"\x8c\x01\n" +
	"\x0fTransformResult\x12%\n" +
	"\x0etransform_type\x18\x01 \x01(\tR\rtransformType\x123\n" +
	"\x05links\x18\x02 \x03(\v2\x1d.markdownsvc.v1.ExtractedLinkR\x05links\x12\x1d\n" +
	"\n" +
	"plain_text\x18\x03 \x01(\tR\tplainText\"_\n" +
	"\rExtractedLink\x12\x10\n" +
	"\x03url\x18\x01 \x01(\tR\x03url\x12\x12\n" +
	"\x04text\x18\x02 \x01(\tR\x04text\x12\x14\n" +
	"\x05title\x18\x03 \x01(\tR\x05title\x12\x12\n" +
	"\x04line\x18\x04 \x01(\x05R\x04line*D\n" +
	"\fOutputFormat\x12\x16\n" +
	"\x12OUTPUT_FORMAT_HTML\x10\x00\x12\x1c\n" +
	"\x18OUTPUT_FORMAT_EMAIL_HTML\x10\x012\x83\x03\n" +
	"\x0fMarkdownService\x12\\\n" +
	"\rParseMarkdown\x12$.markdownsvc.v1.ParseMarkdownRequest\x1a%.markdownsvc.v1.ParseMarkdownResponse\x12Y\n" +
	"\fRenderToHTML\x12#.markdownsvc.v1.RenderToHTMLRequest\x1a$.markdownsvc.v1.RenderToHTMLResponse\x12\\\n" +
	"\rChunkMarkdown\x12$.markdownsvc.v1.ChunkMarkdownRequest\x1a%.markdownsvc.v1.ChunkMarkdownResponse\x12Y\n" +
	"\fTransformAST\x12#.markdownsvc.v1.TransformASTRequest\x1a$.markdownsvc.v1.TransformASTResponseB<Z:github.com/ai8future/markdown_svc/clients/go/markdownsvcv1b\x06proto3"

var (
	file_markdownsvc_v1_markdown_proto_rawDescOnce sync.Once
	file_markdownsvc_v1_markdown_proto_rawDescData []byte
)

func file_markdownsvc_v1_markdown_proto_rawDescGZIP() []byte {
	file_markdownsvc_v1_markdown_proto_rawDescOnce.Do(func() {
		file_markdownsvc_v1_markdown_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_markdownsvc_v1_markdown_proto_rawDesc), len(file_markdownsvc_v1_markdown_proto_rawDesc)))
	})
	return file_markdownsvc_v1_markdown_proto_rawDescData
}

var file_markdownsvc_v1_markdown_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_markdownsvc_v1_markdown_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_markdownsvc_v1_markdown_proto_goTypes = []any{
	(OutputFormat)(0),             // 0: markdownsvc.v1.OutputFormat
	(*ParseMarkdownRequest)(nil),  // 1: markdownsvc.v1.ParseMarkdownRequest
	(*PluginConfig)(nil),          // 2: markdownsvc.v1.PluginConfig
	(*ParseMarkdownResponse)(nil), // 3: markdownsvc.v1.ParseMarkdownResponse
	(*RenderToHTMLRequest)(nil),   // 4: markdownsvc.v1.RenderToHTMLRequest
	(*RenderToHTMLResponse)(nil),  // 5: markdownsvc.v1.RenderToHTMLResponse
	(*ChunkMarkdownRequest)(nil),  // 6: markdownsvc.v1.ChunkMarkdownRequest
	(*ChunkingOptions)(nil),       // 7: markdownsvc.v1.ChunkingOptions
	(*ChunkMarkdownResponse)(nil), // 8: markdownsvc.v1.ChunkMarkdownResponse
	(*MarkdownChunk)(nil),         // 9: markdownsvc.v1.MarkdownChunk
	(*ChunkMetadata)(nil),         // 10: markdownsvc.v1.ChunkMetadata
	(*DocumentOutline)(nil),       // 11: markdownsvc.v1.DocumentOutline
	(*OutlineNode)(nil),           // 12: markdownsvc.v1.OutlineNode
	(*TransformASTRequest)(nil),   // 13: markdownsvc.v1.TransformASTRequest
	(*Transform)(nil),             // 14: markdownsvc.v1.Transform
	(*TransformASTResponse)(nil),  // 15: markdownsvc.v1.TransformASTResponse
	(*TransformResult)(nil),       // 16: markdownsvc.v1.TransformResult
	(*ExtractedLink)(nil),         // 17: markdownsvc.v1.ExtractedLink
}
var file_markdownsvc_v1_markdown_proto_depIdxs = []int32{
	2,  // 0: markdownsvc.v1.ParseMarkdownRequest.plugins:type_name -> markdownsvc.v1.PluginConfig
	14, // 1: markdownsvc.v1.ParseMarkdownRequest.transforms:type_name -> markdownsvc.v1.Transform
	0,  // 2: markdownsvc.v1.ParseMarkdownRequest.output_format:type_name -> markdownsvc.v1.OutputFormat
	16, // 3: markdownsvc.v1.ParseMarkdownResponse.results:type_name -> markdownsvc.v1.TransformResult
	2,  // 4: markdownsvc.v1.RenderToHTMLRequest.plugins:type_name -> markdownsvc.v1.PluginConfig
	0,  // 5: markdownsvc.v1.RenderToHTMLRequest.output_format:type_name -> markdownsvc.v1.OutputFormat
	7,  // 6: markdownsvc.v1.ChunkMarkdownRequest.options:type_name -> markdownsvc.v1.ChunkingOptions
	9,  // 7: markdownsvc.v1.ChunkMarkdownResponse.chunks:type_name -> markdownsvc.v1.MarkdownChunk
	11, // 8: markdownsvc.v1.ChunkMarkdownResponse.outline:type_name -> markdownsvc.v1.DocumentOutline
	10, // 9: markdownsvc.v1.MarkdownChunk.metadata:type_name -> markdownsvc.v1.ChunkMetadata
	12, // 10: markdownsvc.v1.DocumentOutline.nodes:type_name -> markdownsvc.v1.OutlineNode
	12, // 11: markdownsvc.v1.OutlineNode.children:type_name -> markdownsvc.v1.OutlineNode
	14, // 12: markdownsvc.v1.TransformASTRequest.transforms:type_name -> markdownsvc.v1.Transform
	16, // 13: markdownsvc.v1.TransformASTResponse.results:type_name -> markdownsvc.v1.TransformResult
	17, // 14: markdownsvc.v1.TransformResult.links:type_name -> markdownsvc.v1.ExtractedLink
	1,  // 15: markdownsvc.v1.MarkdownService.ParseMarkdown:input_type -> markdownsvc.v1.ParseMarkdownRequest
	4,  // 16: markdownsvc.v1.MarkdownService.RenderToHTML:input_type -> markdownsvc.v1.RenderToHTMLRequest
	6,  // 17: markdownsvc.v1.MarkdownService.ChunkMarkdown:input_type -> markdownsvc.v1.ChunkMarkdownRequest
	13, // 18: markdownsvc.v1.MarkdownService.TransformAST:input_type -> markdownsvc.v1.TransformASTRequest
	3,  // 19: markdownsvc.v1.MarkdownService.ParseMarkdown:output_type -> markdownsvc.v1.ParseMarkdownResponse
	5,  // 20: markdownsvc.v1.MarkdownService.RenderToHTML:output_type -> markdownsvc.v1.RenderToHTMLResponse
	8,  // 21: markdownsvc.v1.MarkdownService.ChunkMarkdown:output_type -> markdownsvc.v1.ChunkMarkdownResponse
	15, // 22: markdownsvc.v1.MarkdownService.TransformAST:output_type -> markdownsvc.v1.TransformASTResponse
	19, // [19:23] is the sub-list for method output_type
	15, // [15:19] is the sub-list for method input_type
	15, // [15:15] is the sub-list for extension type_name
	15, // [15:15] is the sub-list for extension extendee
	0,  // [0:15] is the sub-list for field type_name
}

func init() { file_markdownsvc_v1_markdown_proto_init() }
func file_markdownsvc_v1_markdown_proto_init() {
	if File_markdownsvc_v1_markdown_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_markdownsvc_v1_markdown_proto_rawDesc), len(file_markdownsvc_v1_markdown_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   17,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_markdownsvc_v1_markdown_proto_goTypes,
		DependencyIndexes: file_markdownsvc_v1_markdown_proto_depIdxs,
		EnumInfos:         file_markdownsvc_v1_markdown_proto_enumTypes,
		MessageInfos:      file_markdownsvc_v1_markdown_proto_msgTypes,
	}.Build()
	File_markdownsvc_v1_markdown_proto = out.File
	file_markdownsvc_v1_markdown_proto_goTypes = nil
	file_markdownsvc_v1_markdown_proto_depIdxs = nil
}
